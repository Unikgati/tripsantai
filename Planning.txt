Step 1: Audit dan Persiapan Awal
[x] 1.1 Inventarisasi env vars yang sensitif (Supabase anon & service_role, Cloudinary preset, service keys) dan dokumentasikan lokasi penyimpanan yang aman (CI secrets, vault).
[x] 1.2 Buat file `.env.example` berisi variabel yang diperlukan tanpa nilai sensitif.
[ ] 1.3 Siapkan akun/akses untuk logging/monitoring (Sentry/Logflare/Datadog) dan tambahkan placeholder DSN di `.env.example`.
[ ] 1.4 Pastikan ada backup dari schema DB saat ini (dump SQL) sebelum perubahan.

-- Success condition: `.env.example` dibuat, daftar secrets/akses tersedia, DB dump tersimpan.

Step 2: Penguatan Autentikasi & Otentikasi Admin
[~] 2.1 Kaji ulang penggunaan Supabase anon key di client: pisahkan operasi publik vs admin.
[~] 2.2 Implementasikan authentication flows yang aman:
    [~] 2.2.1 Gunakan Supabase Auth + JWT claims untuk role-based access (user vs admin).
    [ ] 2.2.2 Konfigurasi email/password + provider OIDC jika perlu.
[x] 2.3 Buat server-side admin auth verification endpoint (serverless) yang memverifikasi token JWT dan mengembalikan klaim admin (menggunakan Supabase service_role pada server)
[~] 2.4 Pastikan admin UI hanya aksesable bila klaim admin terverifikasi.

-- Success condition: admin-only routes menolak akses tanpa server-verified admin claim.

Step 3: Pindahkan operasi sensitif ke server-side
[x] 3.1 Identifikasi operasi sensitif di client (upsert destination, delete, upsert blog, invoice create dengan share_token, order updates that change payment/status).
[~] 3.2 Buat serverless endpoints (e.g., Vercel Functions / Netlify Functions / simple Node server) untuk operasi tersebut yang:
    [~] 3.2.1 Menerima request dari client, memverifikasi JWT/admin claim via Supabase service_role.
    [~] 3.2.2 Menjalankan query DB menggunakan service_role key (tidak di-bundle ke client).
    [~] 3.2.3 Mengembalikan result yang disanitasi.
[~] 3.3 Refactor client untuk memakai endpoint ini alih-alih memanggil Supabase langsung untuk sensitive ops.

-- Success condition: sensitive ops tidak lagi memakai service_role atau anon keys di client; semua lewat server.

Step 4: Terapkan Row Level Security (RLS) yang Ketat
[x] 4.1 Aktifkan RLS pada tabel: `destinations`, `blog_posts`, `orders`, `app_settings`, `invoices`.
[x] 4.2 Definisikan role & policy:
    [x] 4.2.1 Public policy: allow SELECT untuk tabel publik (destinations, blog) hanya untuk kolom yang aman.
    [~] 4.2.2 Orders: allow INSERT dari anon users untuk membuat order, tetapi restrict UPDATE/DELETE hanya ke server (service_role) atau pemilik via JWT claim (owner = user_id).
    [x] 4.2.3 Admin-only policy: hanya role yang memiliki claim `role='admin'` (atau supabase auth.uid dalam admin list) dapat INSERT/UPDATE/DELETE pada destinasi/blogs/app_settings/invoices.
[x] 4.3 Buat SQL policy sample di repo (`db/rls.sql`) dan script deploy untuk apply policy ke Supabase.

-- Success condition: semua policies aktif; admin operations gagal tanpa admin claim.

Step 5: Amankan Cloudinary uploads
[~] 5.1 Hindari meletakkan service API key di client. Gunakan unsigned upload preset hanya jika diperlukan.
[ ] 5.2 Jika menggunakan unsigned preset: batasi preset (allowed_formats, max_file_size, folder, auto-tagging) dan dokumentasikan preset id di `.env.example`.
[ ] 5.3 Prefer server-side signed uploads for admin-only uploads: buat server endpoint yang menghasilkan signature menggunakan Cloudinary API key (server-only) dan mengembalikan parameters untuk client upload.
[ ] 5.4 Validasi file type & size server-side saat menerima callback (jika ada) atau sebelum menyimpan URL dalam DB.

-- Success condition: admin uploads menggunakan signed server flow; unsigned preset hanya untuk user uploads with strict limits.

Step 6: Data validation & sanitasi
[~] 6.1 Tambahkan server-side validation layer pada semua serverless endpoints (Zod/Yup): tipe, panjang, allowed values.
[ ] 6.2 Sanitasi HTML input dari rich-text (react-quill) sebelum disimpan (DOMPurify / sanitize-html) pada server.
[~] 6.3 Tambahkan constraints DB (NOT NULL, CHECK, types) sesuai model. Tambahkan migrations dan migrations plan.

-- Success condition: invalid payloads ditolak di server; rich content disanitasi.

Step 7: Observability & Error handling
[ ] 7.1 Integrasikan Sentry (atau Logflare) di client (error boundary) dan server (functions) with environment-aware DSN.
[~] 7.2 Pastikan serverless endpoints log request id, user id, and minimal diagnostics (don't log secrets).
[ ] 7.3 Tambahkan structured logging (JSON) untuk server functions and background jobs.
[ ] 7.4 Tambahkan health-check endpoint dan status page (optional).

-- Success condition: exceptions ditangkap dan tersedia di Sentry with user/context info.

Step 8: Transactions, idempotency, dan concurrency
[~] 8.1 Invoice creation: gunakan DB transaction or upsert logic with unique constraint on order_id to ensure idempotency.
[ ] 8.2 Gunakan advisory locks or DB-level constraints for critical sequences if needed.
[ ] 8.3 Saat melakukan stock/availability updates, gunakan row-level locking to avoid race conditions.

-- Success condition: duplicate invoices tidak pernah dibuat untuk satu order; race conditions mitigated.

Step 9: Testing & CI
[ ] 9.1 Tambahkan unit tests (vitest/jest) untuk lib utama (supabase wrapper, price calc, booking modal logic) dan beberapa integration tests.
[ ] 9.2 Tambahkan e2e smoke tests (Playwright / Cypress) untuk critical flows: booking, admin login, create destination via admin UI.
[~] 9.3 Setup GitHub Actions (or other CI) untuk run tests, type-check, lint, and build.

-- Success condition: CI pipeline runs tests and blocks merges on failing tests.

Step 10: Deployment & Secrets management
[x] 10.1 Pilih hosting dan deployment model (Vercel/Netlify/Static + serverless functions) dan dokumentasikan.
[x] 10.2 Store secrets in provider secret store (Vercel env, GitHub Secrets, or Vault). Remove any service_role keys from client code.
[ ] 10.3 Use environment-specific configs (staging vs production) and rotate keys regularly.

-- Success condition: no service_role keys in client repo and secrets stored in provider secret store.

Step 11: Performance & Caching
[ ] 11.1 Add CDN for static assets and images (Cloudinary + CDN). Ensure proper cache-control headers.
[ ] 11.2 Implement server-side caching for expensive queries (Redis / in-memory) or use Supabase edge functions + caching layer.
[ ] 11.3 Profile page load and heavy endpoints; add pagination for large datasets (orders/destinations).

-- Success condition: recognized bottlenecks mitigated; pages load under target thresholds.

Step 12: Backup, Recovery & Maintenance
[ ] 12.1 Schedule regular DB backups and test restore procedure.
[x] 12.2 Document runbooks for incident response (lost keys, data corruption, high error rates).
[~] 12.3 Create rotation policy for keys and credentials.

-- Success condition: restore tested; runbooks available.

Step 13: Final security review & go-live checklist
[ ] 13.1 Run an internal security review: RLS, CSP, CSP headers, CORS, cookies flags, secure TLS configs.
[ ] 13.2 Penetration test or third-party audit if budget allows.
[ ] 13.3 Prepare cutover checklist: switch DNS, enable analytics, monitor initial traffic.

-- Success condition: sign-off from stakeholders and security engineer.

Notes & References
- Prioritaskan memindahkan semua operasi yang menggunakan service_role key ke server-side.
- Dokumentasi RLS dan sample SQL policy harus disertakan di `db/rls.sql`.
- Untuk sanitasi rich text di server gunakan `dompurify` (server-side) atau `sanitize-html`.

